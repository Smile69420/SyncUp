/**
 * @OnlyCurrentDoc
 *
 * The main entry point for the web app. This function is called when a POST request is made to the script's URL.
 * It handles creating Google Meet links and logging booking data to Google Sheets.
 *
 * @param {object} e The event parameter for a POST request.
 * @returns {ContentService.TextOutput} A JSON response indicating success or failure.
 */
function doPost(e) {
  try {
    // 1. PARSE INCOMING DATA
    const requestBody = e.postData.contents;
    console.log("Received raw request body:", requestBody);
    const data = JSON.parse(requestBody);
    const action = data.action || 'createBooking'; // Default action is to create a booking
    console.log("Executing action:", action);


    // 2. ROUTE REQUEST BASED ON ACTION
    switch (action) {
      case 'updateStatus': {
        const { bookingId, newStatus, sheetId, sheetName } = data;
        if (!bookingId || !newStatus || !sheetId || !sheetName) throw new Error("Missing parameters for updateStatus action.");
        console.log(`Received status update for booking ${bookingId} to "${newStatus}"`);
        updateMeetingStatusInSheet(bookingId, newStatus, sheetId, sheetName);
        return createJsonResponse({ status: 'success', message: 'Status update processed.' });
      }

      case 'deleteBooking': {
        const { bookingId, sheetId, sheetName } = data;
        if (!bookingId) throw new Error("Missing bookingId for deleteBooking action.");
        console.log(`Received delete request for booking ${bookingId}`);
        deleteCalendarEvent(bookingId);
        if (sheetId && sheetName) deleteRowFromSheet(bookingId, sheetId, sheetName);
        return createJsonResponse({ status: 'success', message: 'Deletion processed.' });
      }

      case 'deleteMultipleBookings': {
        const { bookings } = data;
        if (!bookings || !Array.isArray(bookings)) throw new Error("Missing 'bookings' array for deleteMultipleBookings action.");
        console.log(`Received request to delete ${bookings.length} bookings.`);
        bookings.forEach(b => {
          deleteCalendarEvent(b.bookingId);
          if (b.sheetId && b.sheetName) deleteRowFromSheet(b.bookingId, b.sheetId, b.sheetName);
        });
        return createJsonResponse({ status: 'success', message: 'Multi-deletion processed.' });
      }

      case 'rescheduleBooking': {
        const { bookingId, newStartTime, newEndTime, sheetId, sheetName } = data;
        if (!bookingId || !newStartTime || !newEndTime) throw new Error("Missing parameters for rescheduleBooking action.");
        console.log(`Received reschedule request for booking ${bookingId}`);
        updateCalendarEventTime(bookingId, newStartTime, newEndTime);
        if (sheetId && sheetName) updateSheetRowTime(bookingId, newStartTime, newEndTime, sheetId, sheetName);
        return createJsonResponse({ status: 'success', message: 'Reschedule processed.' });
      }
      
      case 'createBooking':
      default: {
        const { eventType, bookingData } = data;
        if (!eventType || !bookingData) throw new Error("Missing eventType or bookingData for new booking.");
        let meetingLink = null;
        if (eventType.mode === 'online' && eventType.conferencing?.provider === 'google-meet') {
          console.log(`Creating Google Meet link for booking ID: ${bookingData.id}`);
          let meetCreationResult = createMeetLinkAndCalendarEvent(eventType, bookingData);
          if (meetCreationResult && meetCreationResult !== "DUPLICATE_REQUEST") {
            meetingLink = meetCreationResult;
            console.log(`Successfully created Meet link: ${meetingLink}`);
          } else {
             console.log(`Meet link was not created or already exists for booking ID: ${bookingData.id}`);
          }
        }
        if (eventType.googleSheetConfig?.sheetId) {
          console.log(`Logging booking ID ${bookingData.id} to Google Sheet.`);
          logToGoogleSheet(eventType, bookingData, meetingLink);
          console.log(`Successfully logged booking ID ${bookingData.id} to Google Sheets.`);
        }
        return createJsonResponse({ status: 'success', meetingLink: meetingLink });
      }
    }

  } catch (error) {
    console.error(`Error in doPost: ${error.toString()} | Raw Request: ${e.postData.contents} | Stack: ${error.stack}`);
    return createJsonResponse({ status: 'error', message: `Script Error: ${error.message}` });
  }
}

function createJsonResponse(obj) {
  return ContentService.createTextOutput(JSON.stringify(obj)).setMimeType(ContentService.MimeType.JSON);
}


/**
 * Finds a booking row by its ID in a Google Sheet and updates its status.
 *
 * @param {string} bookingId The unique ID of the booking to find.
 * @param {string} newStatus The new status to set (e.g., "Completed").
 * @param {string} sheetId The ID of the Google Spreadsheet.
 * @param {string} sheetName The name of the sheet (tab) within the spreadsheet.
 */
function updateMeetingStatusInSheet(bookingId, newStatus, sheetId, sheetName) {
  try {
    const sheet = SpreadsheetApp.openById(sheetId).getSheetByName(sheetName);
    if (!sheet) {
      console.log(`Sheet "${sheetName}" not found. Skipping status update.`);
      return;
    }

    const data = sheet.getDataRange().getValues();
    if (data.length < 1) {
      console.log('Sheet is empty. Skipping update.');
      return;
    }

    const headers = data[0].map(h => String(h)); // Ensure headers are strings
    const bookingIdCol = headers.indexOf('Booking ID');
    const statusCol = headers.indexOf('Meeting Status');

    if (bookingIdCol === -1 || statusCol === -1) {
      console.log('Could not find "Booking ID" or "Meeting Status" column. Available columns:', headers.join(', '));
      return;
    }

    for (let i = 1; i < data.length; i++) {
      if (data[i][bookingIdCol] == bookingId) {
        const rowToUpdate = i + 1;
        sheet.getRange(rowToUpdate, statusCol + 1).setValue(newStatus);
        console.log(`Updated status to "${newStatus}" for booking ID ${bookingId} in row ${rowToUpdate}.`);
        return;
      }
    }

    console.log(`Booking ID ${bookingId} not found in the sheet.`);

  } catch (err) {
    console.error(`Error in updateMeetingStatusInSheet for booking ${bookingId}: ${err.toString()}`);
  }
}


/**
 * Creates a Google Calendar event with a Meet link for the specified booking.
 *
 * @param {object} eventType The event type details.
 * @param {object} bookingData The data for the new booking.
 * @returns {string} The URL of the generated Google Meet link.
 */
function createMeetLinkAndCalendarEvent(eventType, bookingData) {
  const calendarId = 'primary';
  const { bookerName, bookerEmail, startTime, endTime } = bookingData;
  
  const event = {
    summary: `${eventType.name} with ${bookerName}`,
    description: `Booking details for ${eventType.name}.\nBooker: ${bookerName} (${bookerEmail})`,
    start: { dateTime: new Date(startTime).toISOString() },
    end: { dateTime: new Date(endTime).toISOString() },
    attendees: [{ email: bookerEmail }],
    conferenceData: {
      createRequest: {
        requestId: `syncup-${bookingData.id}`,
        conferenceSolutionKey: { type: 'hangoutsMeet' },
      },
    },
    extendedProperties: {
      private: { 'syncUpBookingId': bookingData.id }
    },
    reminders: { useDefault: true }
  };

  try {
    const createdEvent = Calendar.Events.insert(event, calendarId, {
      conferenceDataVersion: 1,
      sendNotifications: true,
    });
    
    if (createdEvent.hangoutLink) {
      return createdEvent.hangoutLink;
    } else {
      throw new Error("Calendar event was created, but no Meet link was generated.");
    }
  } catch (err) {
    if (err.message.includes("conferenceData.createRequest.requestId must be unique")) {
        console.log("Event with this requestId already exists. This may be a retry. Skipping creation.");
        return "DUPLICATE_REQUEST";
    }
    console.error(`Failed to create calendar event: ${err.toString()}`);
    throw new Error(`Google Calendar API Error: ${err.message}`);
  }
}


/**
 * Appends a row with booking information to a specified Google Sheet.
 *
 * @param {object} eventType The event type details, containing sheet configuration.
 * @param {object} bookingData The booking data to log.
 * @param {string|null} meetingLink The generated Google Meet link, if any.
 */
function logToGoogleSheet(eventType, bookingData, meetingLink) {
  try {
    const { sheetId, sheetName } = eventType.googleSheetConfig;
    const sheet = SpreadsheetApp.openById(sheetId).getSheetByName(sheetName);
    
    if (!sheet) {
      throw new Error(`Sheet with name "${sheetName}" not found in Spreadsheet ID "${sheetId}".`);
    }

    const headers = [
      'Booking ID', 'Event Name', 'Meeting Status', 'Date', 'Start Time', 'End Time', 
      'Mode', 'Location / Link', 'Client Name', 'Email', 'Phone', 'Company Name',
      'Consultation Done By', 'Designation', 'Generalized Designation', 'Level', 'Capability',
      'Feedback Sent', 'Shown Interest in Membership', 'Membership', 'Membership Verification',
      'State', 'District', 'Women Entrepreneur', 'No of Employees in Company', 'No of Attendants',
      'Sector', 'Sector Generalized', 'Operations Perfomed In Brief', 'Scale', 'Challenges',
      'Manual Tasks', 'Suggested Tools', 'Tool Categories', 'AI Familiarity (Pre)', 'KPI',
      'AI Familiarity (Post)', 'KPI Value', 'How did they get to know', 'Additional Notes 1',
      'Notes for Report', 'Follow Up Request Status', 'Follow Up Status'
    ];
    const customFieldHeaders = (eventType.customFormFields || []).map(f => f.label);
    const fullHeaders = headers.concat(customFieldHeaders);

    if (sheet.getLastRow() === 0) {
      sheet.appendRow(fullHeaders);
      sheet.getRange('1:1').setFontWeight('bold').setHorizontalAlignment('center');
    }

    // Prepare a map of header to value for easy row construction
    const rowMap = new Map();
    rowMap.set('Booking ID', bookingData.id);
    rowMap.set('Event Name', eventType.name);
    rowMap.set('Meeting Status', 'Scheduled');
    rowMap.set('Date', new Date(bookingData.startTime));
    rowMap.set('Start Time', new Date(bookingData.startTime));
    rowMap.set('End Time', new Date(bookingData.endTime));
    rowMap.set('Mode', eventType.mode);
    rowMap.set('Location / Link', eventType.mode === 'online' ? (meetingLink || eventType.conferencing.customLink || 'N/A') : eventType.location);
    rowMap.set('Client Name', bookingData.bookerName);
    rowMap.set('Email', bookingData.bookerEmail);
    rowMap.set('Phone', bookingData.bookerPhone);
    
    // Map linked fields from custom answers
    (eventType.customFormFields || []).forEach(field => {
        const answer = bookingData.customAnswers[field.id];
        // Log the direct answer to the custom question column
        if (field.type === 'checkbox') rowMap.set(field.label, answer === 'true' ? 'Yes' : 'No');
        else rowMap.set(field.label, answer || 'N/A');
        
        // If the field is linked to a standard column, populate that too
        if (field.linkedRecordField) {
            const headerLabel = headers.find(h => h.toLowerCase().replace(/\s/g, '') === field.linkedRecordField.toLowerCase().replace(/\s/g, ''));
            if(headerLabel) {
                 rowMap.set(headerLabel, answer);
            }
        }
    });

    const rowData = fullHeaders.map(header => rowMap.get(header) || ''); // Use empty string for missing values
    sheet.appendRow(rowData);
    
    const lastRow = sheet.getLastRow();
    sheet.getRange(lastRow, 4).setNumberFormat('yyyy-mm-dd');
    sheet.getRange(lastRow, 5, 1, 2).setNumberFormat('hh:mm am/pm');
    sheet.autoResizeColumns(1, fullHeaders.length);

  } catch (err) {
    console.error(`Failed to log to Google Sheet for booking ${bookingData.id}: ${err.toString()}`);
  }
}

/**
 * Finds and deletes a Google Calendar event associated with a booking ID.
 * @param {string} bookingId The booking ID stored in the event's extended properties.
 */
function deleteCalendarEvent(bookingId) {
  try {
    const events = Calendar.Events.list('primary', {
      privateExtendedProperty: `syncUpBookingId=${bookingId}`,
      showDeleted: false
    }).items;

    if (events && events.length > 0) {
      events.forEach(function(event) {
        console.log(`Deleting calendar event: ${event.id} for booking ID: ${bookingId}`);
        Calendar.Events.remove('primary', event.id);
      });
    } else {
      console.log(`No calendar event found for booking ID: ${bookingId}`);
    }
  } catch (err) {
    console.error(`Error deleting calendar event for booking ${bookingId}: ${err.toString()}`);
  }
}

/**
 * Finds and deletes a row from a Google Sheet based on a booking ID.
 * @param {string} bookingId The booking ID to find in the 'Booking ID' column.
 * @param {string} sheetId The ID of the spreadsheet.
 * @param {string} sheetName The name of the specific sheet/tab.
 */
function deleteRowFromSheet(bookingId, sheetId, sheetName) {
  try {
    const sheet = SpreadsheetApp.openById(sheetId).getSheetByName(sheetName);
    if (!sheet) return console.log(`Sheet "${sheetName}" not found. Skipping row deletion.`);
    const data = sheet.getDataRange().getValues();
    if (data.length < 1) return;

    const headers = data[0].map(h => String(h));
    const bookingIdCol = headers.indexOf('Booking ID');
    if (bookingIdCol === -1) return console.log('Could not find "Booking ID" column. Skipping row deletion.');

    for (let i = data.length - 1; i > 0; i--) {
      if (data[i][bookingIdCol] == bookingId) {
        sheet.deleteRow(i + 1);
        console.log(`Deleted row ${i + 1} for booking ID ${bookingId}.`);
        return;
      }
    }
    console.log(`Booking ID ${bookingId} not found in sheet for deletion.`);
  } catch(err) {
    console.error(`Error deleting row from sheet for booking ${bookingId}: ${err.toString()}`);
  }
}

/**
 * Finds and updates the time of a Google Calendar event.
 * @param {string} bookingId - The booking ID stored in the event's extended properties.
 * @param {string} newStartTimeISO - The new start time in ISO format.
 * @param {string} newEndTimeISO - The new end time in ISO format.
 */
function updateCalendarEventTime(bookingId, newStartTimeISO, newEndTimeISO) {
  try {
    const events = Calendar.Events.list('primary', {
      privateExtendedProperty: `syncUpBookingId=${bookingId}`,
      showDeleted: false
    }).items;

    if (events && events.length > 0) {
      const event = events[0];
      const patch = {
        start: { dateTime: newStartTimeISO },
        end: { dateTime: newEndTimeISO }
      };
      Calendar.Events.patch(patch, 'primary', event.id, { sendNotifications: true });
      console.log(`Rescheduled calendar event ${event.id} for booking ID ${bookingId}.`);
    } else {
      console.log(`No calendar event found to reschedule for booking ID: ${bookingId}`);
    }
  } catch (err) {
    console.error(`Error rescheduling calendar event for booking ${bookingId}: ${err.toString()}`);
  }
}

/**
 * Finds a booking row in a sheet and updates its date and time columns.
 * @param {string} bookingId The unique ID of the booking to find.
 * @param {string} newStartTimeISO The new start time in ISO format.
 * @param {string} newEndTimeISO The new end time in ISO format.
 * @param {string} sheetId The ID of the Google Spreadsheet.
 * @param {string} sheetName The name of the sheet (tab).
 */
function updateSheetRowTime(bookingId, newStartTimeISO, newEndTimeISO, sheetId, sheetName) {
  try {
    const sheet = SpreadsheetApp.openById(sheetId).getSheetByName(sheetName);
    if (!sheet) return;

    const data = sheet.getDataRange().getValues();
    if (data.length < 1) return;

    const headers = data[0].map(h => String(h));
    const bookingIdCol = headers.indexOf('Booking ID');
    const dateCol = headers.indexOf('Date');
    const startTimeCol = headers.indexOf('Start Time');
    const endTimeCol = headers.indexOf('End Time');

    if ([bookingIdCol, dateCol, startTimeCol, endTimeCol].includes(-1)) {
      return console.log("Missing required columns for rescheduling.");
    }

    const newStartTime = new Date(newStartTimeISO);
    const newEndTime = new Date(newEndTimeISO);

    for (let i = 1; i < data.length; i++) {
      if (data[i][bookingIdCol] == bookingId) {
        const rowToUpdate = i + 1;
        sheet.getRange(rowToUpdate, dateCol + 1).setValue(newStartTime).setNumberFormat('yyyy-mm-dd');
        sheet.getRange(rowToUpdate, startTimeCol + 1).setValue(newStartTime).setNumberFormat('hh:mm am/pm');
        sheet.getRange(rowToUpdate, endTimeCol + 1).setValue(newEndTime).setNumberFormat('hh:mm am/pm');
        console.log(`Updated sheet row ${rowToUpdate} for rescheduled booking ID ${bookingId}.`);
        return;
      }
    }
  } catch (err) {
    console.error(`Error updating sheet for rescheduled booking ${bookingId}: ${err.toString()}`);
  }
}